---
title: "Overview of package itp"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Overview of package itp}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: itp.bib
csl: taylor-and-francis-chicago-author-date.csl
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 5, 
  fig.height = 3,
  global.par = TRUE
)
```

@OliveiraTakahashi2021

Wikipedia article [ITP method](https://en.wikipedia.org/wiki/ITP_method)

We use some of the examples presented in Table 1 of @OliveiraTakahashi2021 to illustrate the use of the function `itp` and run the sample examples using the  `uniroot` function in the `stats` package as a means of comparison, using a convergence tolerance of $10^{-10}$ in both cases. The following function prints output from `uniroot` in the same style as the output from `itp`.

```{r}
# Method to print part of uniroot output
print.list <- function(x, digits = max(3L, getOption("digits") - 3L)) {
  names(x)[1:3] <- c("root", "f(root)", "iterations")
  print.default(format(x[1:3], digits = digits), print.gap = 2L, quote = FALSE)
}
```

```{r setup}
library(itp)
```

$(a, b)$

The function `itp` uses the default values $\kappa_1 = 0.2 / (b - a)$, $\kappa_2 = 2$, $n_0 = 1$.

## Well-behaved functions

These functions are infinitely differentiable and contain only one simple root over $[âˆ’1, 1]$.

### Lambert: $f(x) = x e^x - 1$

```{r, fig.align='center'}
# Lambert
lambert <- function(x) x * exp(x) - 1
itp(lambert, c(-1, 1))
uniroot(lambert, c(-1, 1), tol = 1e-10)
```

```{r, echo = FALSE, fig.align='center'}
oldpar <- par(mar = c(4, 4, 1, 1))
curve(lambert, -1, 1, main = "Lambert")
abline(h = 0, lty = 2)
abline(v = itp(lambert, c(-1, 1))$root, lty = 2)
par(oldpar)
```

### Trigonometric 1: $f(x) = \tan(x - 1 / 10)$

```{r, fig.align='center'}
# Trigonometric 1
trig1 <- function(x) tan(x - 1 /10)
itp(trig1, c(-1, 1))
uniroot(trig1, c(-1, 1), tol = 1e-10)
```

```{r, echo = FALSE, fig.align='center'}
oldpar <- par(mar = c(4, 4, 1, 1))
curve(trig1, -1, 1, main = "Trigonometric 1")
abline(h = 0, lty = 2)
abline(v = itp(trig1, c(-1, 1))$root, lty = 2)
par(oldpar)
```

## Ill-behaved functions

### Polynomial 3: $f(x) = (10^6 x - 1) ^ 3$

This function has a non-simple root at $10^{-6}$, with a multiplicity of 3.

```{r, fig.align='center'}
# Polynomial 3
poly3 <- function(x) (x * 1e6 - 1) ^ 3
itp(poly3, c(-1, 1))
# Using n0 = 0 leads to 1 (slightly) fewer iterations, in this example
poly3 <- function(x) (x * 1e6 - 1) ^ 3
itp(poly3, c(-1, 1), n0 = 0)
uniroot(poly3, c(-1, 1), tol = 1e-10)
```

```{r, echo = FALSE, fig.align='center'}
oldpar <- par(mar = c(4, 4, 1, 1))
curve(poly3, -1, 1, main = "Polynomial 3")
abline(h = 0, lty = 2)
abline(v = itp(poly3, c(-1, 1))$root, lty = 2)
par(oldpar)
```

### Discontinuous

### Staircase: $f(x) = \lceil 10 x - 1 \rceil + 1/2$

This function has discontinuities, including one at the location of the root.

```{r, fig.align='center'}
# Staircase
staircase <- function(x) ceiling(10 * x - 1) + 1 / 2
itp(staircase, c(-1, 1))
uniroot(staircase, c(-1, 1), tol = 1e-10)
```

```{r, echo = FALSE, fig.align='center'}
oldpar <- par(mar = c(4, 4, 1, 1))
curve(staircase, -1, 1, main = "Staircase", n = 10000)
abline(h = 0, lty = 2)
abline(v = itp(staircase, c(-1, 1))$root, lty = 2)
par(oldpar)
```

### Multiple roots

### Warsaw: $f(x) = I(x > -1)\left(1 + \sin\left(\frac{1}{1+x}\right)\right)-1$

This function has multiple roots, but we only seek one of them.

```{r, fig.align='center'}
# Warsaw
warsaw <- function(x) ifelse(x > -1, sin(1 / (x + 1)), -1)
itp(warsaw, c(-1, 1))
uniroot(warsaw, c(-1, 1), tol = 1e-10)
```

```{r, echo = FALSE, fig.align='center'}
oldpar <- par(mar = c(4, 4, 1, 1))
curve(warsaw, -0.9999999, 1, main = "Warsaw", n = 1000)
abline(h = 0, lty = 2)
abline(v = itp(warsaw, c(-1, 1))$root, lty = 2)
par(oldpar)
```

## ... and finally

The function `itp` has an argument `fsign` that can be used to control the sign of the function at the estimated root. This may be unnecessary for most problems, but this is included because I had a problem where I needed to avoid the function having a negative value at the estimated root. We return to the trigonometric and staircase examples above to illustrate this.

```{r}
# Trigonometric 1
itp(trig1, c(-1, 1))
# Forcing f(root) to be >= 0 requires 1 more iteration
itp(trig1, c(-1, 1), fsign = "ge")

# Staircase
itp(staircase, c(-1, 1))
# Forcing f(root) to be <= 0 requires 24 more iterations
itp(staircase, c(-1, 1), fsign = "le")
```

